<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Fortgeschrittene Aufgaben | Jonas Jansen</title> <meta name="author" content="Jonas Jansen"> <meta name="description" content="Jonas Jansen's webpage "> <meta name="keywords" content="jansen, science communication, academia, pattern formation, Fraunhofer"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.png"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://jonas-jansen.github.io/projects/aufgaben-2/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Jonas </span>Jansen</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/asymptotic-models/">joint seminar</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">curriculum vitae</a> </li> <li class="nav-item "> <a class="nav-link" href="/sommerschule/">sommerschule</a> </li> <li class="nav-item "> <a class="nav-link" href="/talks/">talks</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Fortgeschrittene Aufgaben</h1> <p class="post-description"></p> </header> <article> <h1 id="iterative-numerische-verfahren">Iterative numerische Verfahren</h1> <h3 id="das-heron-verfahren">Das Heron-Verfahren</h3> <p>In dieser Aufgabe lernen wir ein Verfahren kennen, dass die Quadratwurzel einer positiven reellen Zahl annähert. Eine Annäherung genügt für numerische Probleme vollständig, da zum Beispiel schon $\sqrt{2}$ irrational ist und nicht als Bruch zweier Zahlen geschrieben werden kann. Das heißt, für einen Computer ist $\sqrt{2}$ am einfachsten als $1.4142135623730950$ darstellbar.</p> <p>Natürlich könnten wir einfach <code class="language-plaintext highlighter-rouge">math</code> oder <code class="language-plaintext highlighter-rouge">numpy</code> importieren und die Funktionen <code class="language-plaintext highlighter-rouge">math.sqrt</code>oder <code class="language-plaintext highlighter-rouge">numpy.sqrt</code>verwenden. Hier lernen wir aber das Heron-Verfahren, das sehr schnell die Wurzel einer positiven reellen Zahl berechnet.</p> <p>Die Idee dabei ist die folgende: sei $A$ die Zahl, deren Quadratwurzel gesucht ist. Dann wissen wir, dass $\sqrt{A}^2 = A$ gelten soll. Das bedeutet, $\sqrt{A}$ ist die Seitenlänge des Quadrats mit Flächeninhalt $A$. Wenn wir also das Quadrat konstruieren können, sind wir fertig. Und dies machen wir iterativ.</p> <p>Wir beginnen, sehr naiv, mit einem Rechteck mit den Seitenlängen $x_1 = A$ und $y_1 = 1$. Dieses Rechteck hat den Flächeninhalt $x_1\cdot y_1 = A$. Nun möchten wir das Rechteck so verändern, dass es mehr wie ein Quadrat aussieht. Und das machen wir so: stelle dir vor $x_1 &gt; y_1$. Dann wollen wir $x_1$ verkleinern und $y_1$ vergrößern. Eine ganz einfache Möglichkeit das zu tun, ist den Mittelwert der beiden Zahlen zu verwenden, also \(x_2 = \frac{x_1+y_1}{2}.\) Frage: Wie muss $y_2$ gewählt werden, damit das Rechteck mit den Seitenlängen $x_2$ und $y_2$ den Flächeninhalt $A$ hat?</p> <p>Nun haben wir ein neues Rechteck mit den Seitenlängen $x_2$ und $y_2$. Und damit können wir wieder von vorne anfangen. (Wann immer wir hören, dass sich ein Prozess wiederholt, sollten wir daran denken, eine Schleife zu verwenden.)</p> <table> <tbody> <tr> <td>Und genau das tun wir und wiederholen diesen Schritt immer und immer wieder. Aber wie lange? Wir sind ja nun nur daran interessiert, eine Näherung zu finden. Also würden wir gerne sagen können, wann $x_k$ (oder $y_k$, das ist egal) ungefähr $\sqrt{A}$ ist. Aber das ist einfach: denn, wenn $x_k^2 \sim A$, dann muss $x_k \sim \sqrt{A}$ sein. Aber wie können wir das ungefähr implementieren? Dafür legen wir ganz am Anfang eine Fehlertoleranz fest. Dafür definieren wir uns eine <code class="language-plaintext highlighter-rouge">float</code>-Variable <code class="language-plaintext highlighter-rouge">fehlertoleranz</code> und testen am Ende jeder Iteration, ob $</td> <td>x_k^2 - A</td> <td>&lt; fehlertoleranz$ ist. Wenn ja, brechen wir die Schleife ab. Wählen wir jetzt <code class="language-plaintext highlighter-rouge">fehlertoleranz</code>sehr klein, können wir sicher sein, dass wir $\sqrt{A}$ gut approximiert haben.</td> </tr> </tbody> </table> <p>Aufgabe: implementiere eine Funktion <code class="language-plaintext highlighter-rouge">Heron</code>, die die Quadratwurzel jeder positiven reellen Zahl mit einer gegebenen Fehlertoleranz bestimmt.</p> <h3 id="das-newton-verfahren">Das Newton-Verfahren</h3> <p>In dieser Aufgabe lernen wir eine Möglichkeit kennen, schnell Nullstellen von Funktionen anzunähern, das heißt, wir lösen die Gleichung \(f(x) = 0\) für eine Funktion $f$. Zum Beispiel könnte $f(x) = 4x^3 - 6x^2 + 1$ sein. Die Idee ist nun folgende: wir wählen uns irgendeinen Startpunkt $x_0$ und bestimmen die Tangente an den Punkt $x_0$.</p> <p>Erinnerung: die Tangente an den Punkt $x_0$ von $f$ hat die Form $y = f’(x_0) x + n$. Um $n$ zu bestimmen, bemerken wir, dass bei $x=x_0$ also $y=f(x_0)$ gelten muss, also $f(x_0) = f’(x_0)x_0 + n$, oder, nach $n$ aufgelöst, $n= f(x_0) - f’(x_0)x_0$. (Wenn du das nicht sofort siehst, macht das nichts. Probiere die Rechnung mal mit der expliziten Funktion oben und $x_0=1$ selbst aus.) Das gibt uns die Tangentengleichung $y= f’(x_0) x + f(x_0) - f’(x_0)x_0$.</p> <p>Dann suchen wir einfach die Nullstelle der Tangente und nennen den Punkt $x_1$. Es gilt \(x_1 = x_0 - \frac{f(x_0)}{f'(x_0)}.\) Überzeuge dich selbst davon, dass das Ergebnis stimmt. Wie beim Heron-Verfahren können wir das nun iterativ fortsetzen und genau dann aufhören, wenn \(]f(x_n)| &lt; fehlertoleranz\) für eine vorher festgelegte Fehlertoleranz ist.</p> <p>Um das zu implementieren benötigen wir: eine Funktion <code class="language-plaintext highlighter-rouge">f(x)</code>und eine Funktion <code class="language-plaintext highlighter-rouge">ableitung_f(x)</code> und dann eine Funktion <code class="language-plaintext highlighter-rouge">Newton(x_0,fehlertoleranz,f,ableitung_f)</code>.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1) Implementiere das Newton-Verfahren wie oben.
2) Momentan müssen wir noch für jede Funktion die Ableitung von Hand berechnen. Das kann aber schnell sehr kompliziert werden. Hast du eine Idee, wie man die Ableitung einer Funktion annäherungsweise bestimmen kann?
</code></pre></div></div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Jonas Jansen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script> </body> </html>